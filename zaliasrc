# ~/.zaliasrc
# zsh aliases definitions, sourced from ~/.zshrc
# (interactive shells only)

# ls
alias ll='ls -lh'
alias la='ls -A'
alias l='ls -lAh'

# navigation
alias cl="cd; clear"
alias -g ...='../..'
alias -g ....='../../..'
alias -g .....='../../../..'
alias d='dirs -v'

# powerful vim variants
if which medit >/dev/null; then
    kvim() { kpsewhich      "$@" | medit }
    pvim() { pwhich         "$@" | medit }
    lvim() { locate         "$@" | medit }
    wvim() {
        local res
        local problem
        res=$(which "$@")
        problem=$?
        if test $problem -ne 0; then
            echo $res
            return $problem
        fi
        echo $res | medit
    }
fi

# misc (from zsh-lovers)
alias j='jobs'
alias -g C='| wc -l'
alias -g G='| egrep'
alias -g L="| less"
alias -g LL='2>&1 | less'
alias -g TL='| tail -20'
alias -g T='| tail'
alias -g H='| head'
alias -g HL='|& head -20'
alias -g S='| sort'
alias -g N='>/dev/null'
alias -g DN='/dev/null'
alias -g NE='2>/dev/null'
alias -g NUL='>/dev/null 2>&1'
alias -g X0='| xargs -0'
alias -g X='| xargs'

# zsh tunning
alias mkdir='nocorrect mkdir'
alias smv='noglob zmv -W'
alias find='noglob find'
which wget N && alias wget='noglob wget'
which locate N && alias locate='noglob locate'
which youtube-dl N && alias youtube-dl='noglob youtube-dl'

# keyboard setting
alias azerty='setxkbmap $( cat ~/.Xkbmap )'
alias qwerty='setxkbmap -layout fr -option'

# misc
alias mpt='ssh -t thue mocp'
which qmv N && alias qmv='qmv -f do'
alias du1="du -x -h --max-depth 1 . | grep -E '^([0-9]*M|[0-9,]*G)' "
which ionice N && alias vnice='ionice -c3 nice'
alias sgrep='grep -R --exclude-dir=.svn'
alias ggrep='grep -R --exclude-dir=.git'
alias -g GBA='$(git branch -a | sed '\''s/[* ]*\([^ ]*\).*/\1/'\'')'
which mocp N && alias wakeup='echo "mocp -p" |'
which nc N && alias nc='nc -v -w3'
which dd N && which dcfldd N && alias dd='dcfldd'

# cd ripping
if which cdparanoia N; then
    rip () {
        local ext=${1-ogg}

        cdparanoia -B || return

        for i in *.wav; do
            local o=${i#track}
            o=${o%.cdda.wav}.$ext
            case $ext in
                ogg)    oggenc -q5 -o $o $i;;
                flac)   flac --best -o $o $i;;
                mp3)    lame $i $o;;
                *)      false;;
            esac && rm $i
        done
    }
fi

# screencasts with recordmydesktop
if which recordmydesktop N; then
    alias recordmydesktop='recordmydesktop --workdir ~/tmp'
    alias screencast='echo "*** ctrl-alt-s pour finir ***"; recordmydesktop --delay 5 --channels 1 --s_quality 0 --v_quality 16'
fi

# generate random password
pwgen() {
    head -c ${1-10} /dev/urandom | base64
}

# quick RFC access
if [ -d ~/doc/rfcs ]; then
    rfc() {
        view ~/doc/rfcs/rfc$1.txt
    }
fi

# convert any sound to wav
if which mplayer N; then
    sound2wav() {
        for f in "$@"; do
            mplayer -quiet -vo null -vc null -ao pcm:file="${f%.*}".wav $f
        done
    }
fi

# turn cal to cal -3 iby default if supported
if cal -3 NUL; then
    alias cal=_cal
    _cal() {
        if [ $# -eq 0 ]; then
            set -- -3
        fi
        \cal "$@"
    }
fi

# make xpdf open multiple files quietly in the background
if which xpdf NUL; then
    alias xpdf=_xpdf
    _xpdf() {
        for i in "$@"; do
            setsid \xpdf $i NUL
        done
    }
fi

# convert to PDF 1.4 (some old printers don't support better)
if which gs N; then
    pdf14() {
        local out
        case $# in
            1)
                out=${1%.pdf}-pdf14.pdf
                ;;
            2)
                out=$2
                ;;
            *)
                echo 'Usage: pdf14 infile [outfile]' 1>&2
                return 1
        esac
        gs -o $out -sDEVICE=pdfwrite -dCompatibilityLevel=1.4 $1
    }
fi

# sshfs mounts
if which sshfs N && which fusermount N; then
    smount () {
        mkdir -p ~/$1
        sshfs -o ro $1: ~/$1
    }
    sumount () {
        fusermount -uz ~/$1
    }
fi

# mbedtls sync to thue
alias psync='rsync -av --delete ~/src/mbedtls/.git/ thue:mbedtls/mpg.git/'

# mbedtls cmake settings
pcmake () {
    local usage="Usage: [CC=clang] pcmake sb|deb|rel|cov|asan|dasan|mem|dmem|check|off"

    if [ -d library -a -d include -a -d tests ]; then :; else
        echo "Must be run from mbedtls root" >&2
        return 1
    fi

    local mode=""
    local pre=""
    local cc=""

    if [ "x$CC" = "x" ]; then cc=cclang; else cc=$CC; fi

    case "$1" in
        deb)    mode="Debug"                    ;;
        rel)    mode="Release"                  ;;
        cov)    mode="Coverage"; cc=gcc         ;;
        asan)   mode="ASan"                     ;;
        dasan)  mode="ASanDbg"                  ;;
        mem)    mode="MemSan"                   ;;
        dmem)   mode="MemSanDbg"                ;;
        check)  mode="Check"                    ;;
        sb)     mode="Debug"; pre="scan-build"  ;;
        off)                                    ;;
        *)      echo "$usage" >&2; return 1     ;;
    esac

    echo "Cleaning built files..."
    make clean
    echo "Cleaning cmake files..."
    if [ -f include/Makefile ]; then
        rm -f include/**/Makefile
        rm -f programs/*/Makefile
    fi
    find . -name yotta -prune -o -iname '*cmake*' -not -name CMakeLists.txt -exec rm -rf {} \+
    if [ -n "$mode" ]; then
        if git status | grep 'modified:.*/Makefile'; then
            echo "Refusing to overwrite modified Makefile"
            return 1
        fi
        echo "Generating cmake files..."
        CC=$cc $pre cmake -D CMAKE_BUILD_TYPE="$mode" .
        echo "Protecting cmake Makefiles from git..."
        git update-index --skip-worktree {.,library,programs,tests}/Makefile
    else
        echo "Unprotecting cmake Makefiles from git..."
        git update-index --no-skip-worktree {.,library,programs,tests}/Makefile
        echo "Restoring repository Makefiles..."
        git checkout -- {.,library,programs,tests}/Makefile
    fi
    echo "Done."
}

# managing permissions
nox() { find $* \! -type d \! -type l -exec chmod a-x {} + }
pub() { find $* \! -type l -exec chmod a+r {} + , -type d -exec chmod a+x {} + }

# debian stuff
if which aptitude >/dev/null; then
    alias acs='apt-cache search'
    alias acw='apt-cache show'
    alias acp='apt-cache policy'
    alias dqw='dpkg-query -W -f='\''${Package;-40}${Version}\n'\'' | egrep'
fi

# text to pdf
if which paps N && which ps2pdf N; then
    t2p() {
        paps $1 | ps2pdf - ${1%.txt}.pdf
    }
fi

# xkcd password generation
if [ -d ~/usr/xkcd-password ]; then
    xkpw() {
        local dir=~/usr/xkcd-password
        for i in $(seq 1 20); do
            python $dir/xkcd-password.py -w $dir/pwords-fr.txt --min=3 --max=5
        done
    }
fi

# count cycles with valgrind
if which valgrind N; then
    ccount() {
        ( valgrind --tool=callgrind \
            --dump-line=no --callgrind-out-file=/dev/null \
            --collect-atstart=no --toggle-collect=main \
            $1) 2>&1 | sed -n -e 's/.*refs: *\([0-9,]*\)/\1/p'
    }
fi

# sml/nj
if which sml N; then
    which rlwrap N && alias sml='rlwrap sml'
    smlrun() {
        echo 'use "'$1'";' | sml
    }
fi

# get total running time of a bunch of mp3 files
if which mpg123 N; then
    mp3total() {
        local t=0
        for i in "$@"; do
            mpg123 -t $i 2>&1 | sed -n 's/^\[\([0-9]*\):\([0-9]*\)].*/\1 \2/p'
        done | while read m s; do
            t=$(( t + 60 * m + s ))
        done
        echo "$(( t / 3600 )):$(( (t % 3600) / 60 )):$(( t % 60 ))"
    }
fi

if which latex N; then
    # cleaning up after (La)TeX
    tc() {
        setopt local_options nullglob
        exts='.aux|.log|.dvi|.ps|.bbl|.out|.snm|.nav|.toc|.vrb|.blg|.glo|.idx|.mtc'
        exts="$exts|.maf|.stc?|.mtc?|.ptc?|ilg|ind|-blx.bib|.svn|.vex|.exa|.out"
        exts="$exts|.lot|.lof|.idx|.fdb_latexmk|.nlo|.nls|.run.xml|.fls"
        stars='.'
        if [[ $1 = "-r" ]]; then
            stars='**'
            shift
        fi
        basedir='.'
        if [[ -n $1 ]]; then
            basedir="$1"
        fi
        target=( $basedir/${~stars}/*(${~exts}) )
        if [[ -n $target ]]; then
            rm -- $target || return $?
        fi
        target=( $basedir/${~stars}/texput.* )
        if [[ -n $target ]]; then
            rm $target
        fi
    }

    # texmfhome management
    rmtexmfhome() {
        local texmfhome=$(kpsewhich --var-value TEXMFHOME)
        for pack in $@; do
            find $texmfhome -type d -name $pack -exec rm -r {} +
        done
    }
    lstexmfhome() {
        for dir in ~/texmf/tex/*/*; do
            echo ${dir##*/}
        done
    }
fi

# texlive dev
if [ -n "${TEXLIVE+x}" ]; then
    tll-ctan2 () { ctan2tl $1 >$TEXLIVE/p-$1.log }
    tll-place () { ctan2tl --place $1 >$TEXLIVE/p-$1.place }
    tll-ci ()
    {
        svn ci \
            $(cat /tmp/1000.tlplace.dirs) \
            $TLROOT/tlpkg/bin/tlpkg-ctan-check \
            $TLROOT/tlpkg/libexec/ctan2tds \
            $@
    }
    tll-log ()
    {
        if [[ -z $1 ]]; then 1=20; fi
        svn log --limit $1 $TLROOT/.. | less
    }

    alias tll-db='tl-update-tlpdb --catalogue=$TEX_CATALOGUE/..'
    alias tll-net='tl-update-tlnet $TEXLIVE/mynet/tlnet'

    generic_ctan_cd () {
        destination=$(tlpkginfo $1 $2)
        if [[ -n $destination ]]; then cd $destination; fi
    }
    ccd () { generic_ctan_cd --ctan-dir $1 }
    ctd () { generic_ctan_cd --prepare $1 }
fi

# make the current (terminal) window fullscreen
which wmctrl N && alias fullscreen='wmctrl -r :ACTIVE: -b toggle,fullscreen'

# avoid annoying error code on startup when last test was negative
true

# vim: ft=zsh:
